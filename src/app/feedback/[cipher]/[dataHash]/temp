"use client";

import { useState, useEffect } from "react";
import { useParams } from "next/navigation";
import { ethers } from "ethers";
import { LitNodeClient } from "@lit-protocol/lit-node-client";
import { LIT_NETWORK, LIT_ABILITY, LIT_RPC } from "@lit-protocol/constants";
import {
  LitAccessControlConditionResource,
  LitActionResource,
  createSiweMessage,
  generateAuthSig,
} from "@lit-protocol/auth-helpers";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { toast } from "@/components/ui/use-toast";

const customNetworkConfig = {
  chainId: "0x2ac54", // 175188 in hexadecimal
  chainName: "Chronicle Yellowstone - Lit Protocol Testnet",
  nativeCurrency: {
    name: "Lit Protocol Test Token",
    symbol: "tstLPX",
    decimals: 18,
  },
  rpcUrls: ["https://yellowstone-rpc.litprotocol.com/"],
  blockExplorerUrls: ["https://yellowstone-explorer.litprotocol.com/"],
};

export default function Feedback() {
  const [litNodeClient, setLitNodeClient] = useState<LitNodeClient | null>(null);
  const [isWalletConnected, setIsWalletConnected] = useState(false);
  const [isCustomNetworkAdded, setIsCustomNetworkAdded] = useState(false);
  const [currentNetwork, setCurrentNetwork] = useState<string | null>(null);
  const params = useParams();
  const cipher = params.cipher as string;
  const dataHash = params.dataHash as string;

  useEffect(() => {
    const initLitClient = async () => {
      const client = new LitNodeClient({
        litNetwork: LIT_NETWORK.DatilTest,
        rpc: LIT_RPC.CHRONICLE_YELLOWSTONE,
      });
      await client.connect();
      setLitNodeClient(client);
    };

    initLitClient();
  }, []);

  const addAndSwitchToCustomNetwork = async () => {
    if (typeof window.ethereum !== 'undefined') {
      try {
        // Add the custom network
        await window.ethereum.request({
          method: 'wallet_addEthereumChain',
          params: [customNetworkConfig],
        });
        setIsCustomNetworkAdded(true);

        // Switch to the custom network
        await window.ethereum.request({
          method: 'wallet_switchEthereumChain',
          params: [{ chainId: customNetworkConfig.chainId }],
        });

        setCurrentNetwork(customNetworkConfig.chainName);
        toast({
          title: "Network switched",
          description: `Switched to ${customNetworkConfig.chainName}`,
        });
      } catch (error) {
        console.error("Error adding/switching custom network:", error);
        toast({
          title: "Error",
          description: "Failed to add or switch to custom network. Please try again.",
          variant: "destructive",
        });
      }
    } else {
      toast({
        title: "Error",
        description: "MetaMask is not installed. Please install MetaMask and try again.",
        variant: "destructive",
      });
    }
  };

  const connectWallet = async () => {
    if (typeof window.ethereum !== 'undefined') {
      try {
        // Ensure we're on the correct network
        if (!isCustomNetworkAdded) {
          await addAndSwitchToCustomNetwork();
        } else {
          await window.ethereum.request({
            method: 'wallet_switchEthereumChain',
            params: [{ chainId: customNetworkConfig.chainId }],
          });
        }

        const provider = new ethers.providers.Web3Provider(window.ethereum, "any");
        await provider.send("eth_requestAccounts", []);
        const signer = provider.getSigner();
        const address = await signer.getAddress();
        setIsWalletConnected(true);
        setCurrentNetwork(customNetworkConfig.chainName);
        toast({
          title: "Wallet connected",
          description: `Connected to address: ${address} on ${customNetworkConfig.chainName}`,
        });
      } catch (error) {
        console.error("Error connecting wallet:", error);
        toast({
          title: "Error",
          description: "Failed to connect wallet. Please ensure you're on the correct network and try again.",
          variant: "destructive",
        });
      }
    } else {
      toast({
        title: "Error",
        description: "MetaMask is not installed. Please install MetaMask and try again.",
        variant: "destructive",
      });
    }
  };

  const generateSignature = async () => {
    if (!litNodeClient || !isWalletConnected) {
      toast({
        title: "Error",
        description: "Please connect your wallet and ensure Lit client is initialized.",
        variant: "destructive",
      });
      return;
    }

    try {
      const provider = new ethers.providers.Web3Provider(window.ethereum, "any");
      const signer = provider.getSigner();
      
      // Ensure we're on the correct network before proceeding
      const network = await provider.getNetwork();
      if (network.chainId !== parseInt(customNetworkConfig.chainId, 16)) {
        throw new Error("Please switch to the Chronicle Yellowstone network before generating a signature.");
      }
      
      const sessionSignatures = await litNodeClient.getSessionSigs({
        chain: customNetworkConfig.chainName,
        expiration: new Date(Date.now() + 1000 * 60 * 10).toISOString(), // 10 minutes
        resourceAbilityRequests: [
          {
            resource: new LitAccessControlConditionResource("*"),
            ability: LIT_ABILITY.AccessControlConditionDecryption,
          },
          {
            resource: new LitActionResource('*'),
            ability: LIT_ABILITY.LitActionExecution,
          },
        ],
        authNeededCallback: async ({ uri, expiration, resourceAbilityRequests }) => {
          const toSign = await createSiweMessage({
            uri,
            expiration,
            resources: resourceAbilityRequests,
            walletAddress: await signer.getAddress(),
            nonce: await litNodeClient.getLatestBlockhash(),
            litNodeClient,
          });
      
          return await generateAuthSig({
            signer: signer,
            toSign,
          });
        },
      });

      const litActionCode = `
        (async () => {
          console.log("This is my Lit Action on Chronicle Yellowstone!");
        })();
      `;

      const res = await litNodeClient.executeJs({
        code: litActionCode,
        sessionSigs: sessionSignatures,
      });

      console.log(res);
      toast({
        title: "Signature generated",
        description: "Lit Action executed successfully on Chronicle Yellowstone.",
      });
    } catch (error) {
      console.error("Error generating signature:", error);
      toast({
        title: "Error",
        description: `Failed to generate signature: ${error.message}`,
        variant: "destructive",
      });
    }
  };

  return (
    <div className="container mx-auto p-4">
      <Card>
        <CardHeader>
          <CardTitle>Feedback</CardTitle>
        </CardHeader>
        <CardContent>
          <p className="mb-4">Feedback for cipher: {cipher}</p>
          <p className="mb-4">Data hash: {dataHash}</p>
          <p className="mb-4">Current Network: {currentNetwork || "Not connected"}</p>
          <div className="space-y-4">
            <Button onClick={addAndSwitchToCustomNetwork} disabled={isCustomNetworkAdded}>
              {isCustomNetworkAdded ? "Custom Network Added" : "Add & Switch to Custom Network"}
            </Button>
            <Button onClick={connectWallet} disabled={isWalletConnected}>
              {isWalletConnected ? "Wallet Connected" : "Connect Wallet"}
            </Button>
            <Button onClick={generateSignature} disabled={!isWalletConnected || !litNodeClient}>
              Generate Signature
            </Button>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}

